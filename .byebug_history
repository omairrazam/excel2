c
@current_machine.offtimes.first.date.to_time.to_i
@current_machine.offtimes.first.date
@current_machine.offtimes.first.dat
@current_machine.offtimes.first
c
self.offtimes.where(date: date).first_or_initialize
self.offtimes
self.offtimes.find_or_initialize_by_id(1)
Offtime.find_or_initialize_by_date(date)
self.offtimes.find_or_initialize_by_date(date)
c
n
self.datums.all.where('Date>=?', starting_date).group_by{ |dat| dat.Date.to_date }
starting_date
n
starting_date
n
self.offtimes.last.try(:date)
c
self.offtimes.last.try(:date)
self.offtimes.last
self.offtimes
self.offtimes.last.date rescue nil
self.offtimes.last.date
c
n
c
offtime_last_date.blank?
offtime_last_date.absent?
c
self.offtimes.last
datum_last_date = self.datums.last.Date
datum_last_date = self.datums.last.pluck(:Date)
c
dat.Date
dat.date
dat.id
n
c
dat.id
n
time_difference
n
dat.id
n
dat.id
n
dat.id
n
date_offtime
n
last_compared_id
last_compare_id
n
dat.id
time_difference
n
dat.id
n
dat.id
n
dat.id
date_offtime
n
time_difference
n
dat.id
n
dat.id
n
date_offtime
n
time_difference
n
dat.id
date_offtime
dat.id
n
date_offtime
last_compared_id
n
time_difference
n
dat.id
n
date_offtime
date_off_time
n
time_difference
n
dat.id
n
dat.id
n
dat.id < last_compared_id
date_offtime
n
date_offtime
last_compared_id
n
c
n
last_compared_id
n
time_difference
n
next_on_datum.count
next_on_datum
c
date.class
next_on_datum.first.Time.minus_with_coercion(dat.Time)/60
dat.Time.minus_with_coercion(next_on_datum.first.Time)/60
dat.Time.minus_with_coercion(next_on_datum.first.Time)
next_on_datum.first.Time
next_on_datum.Time
dat.Time.class
dat.Time.minus_with_coercion(next_on_datum.Time)
dat.Time
dat
